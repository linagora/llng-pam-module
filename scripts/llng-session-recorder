#!/bin/bash
#
# llng-session-recorder - Record SSH sessions for audit purposes
#
# This script is designed to be used as ForceCommand in sshd_config
# to record all SSH sessions passing through a bastion host.
#
# Supports two recording formats:
# - ttyrec: Binary format, compact, standard tools (ttyrec/ttyplay)
# - asciinema: JSON format, web-friendly, modern (asciinema.org)
#
# Copyright (C) 2025 Linagora
# License: AGPL-3.0

set -euo pipefail

VERSION="1.0.0"
PROG_NAME=$(basename "$0")

# Default configuration
CONFIG_FILE="${LLNG_RECORDER_CONFIG:-/etc/llng/session-recorder.conf}"
SESSIONS_DIR="${LLNG_SESSIONS_DIR:-/var/lib/llng-sessions}"
FORMAT="${LLNG_RECORDER_FORMAT:-asciinema}"
MAX_SESSION_DURATION="${LLNG_MAX_SESSION:-86400}"  # 24 hours default

# Metadata
SESSION_ID=""
SESSION_USER="${USER:-unknown}"
SESSION_START=""
SESSION_FILE=""
METADATA_FILE=""
ORIGINAL_COMMAND="${SSH_ORIGINAL_COMMAND:-}"
CLIENT_IP="${SSH_CLIENT%% *}"
TTY_NAME="${SSH_TTY:-notty}"

# Logging to syslog
log_info() {
    logger -t "$PROG_NAME" -p auth.info "$*"
}

log_warn() {
    logger -t "$PROG_NAME" -p auth.warning "$*"
}

log_err() {
    logger -t "$PROG_NAME" -p auth.err "$*"
}

# Generate unique session ID (UUID v4)
generate_session_id() {
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
    elif [ -r /proc/sys/kernel/random/uuid ]; then
        cat /proc/sys/kernel/random/uuid
    else
        # Fallback: timestamp + random
        echo "$(date +%Y%m%d%H%M%S)-$(head -c 8 /dev/urandom | od -An -tx1 | tr -d ' \n')"
    fi
}

# Load configuration file
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Source config file safely (only specific variables)
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$key" ]] && continue

            # Remove quotes and whitespace
            key=$(echo "$key" | tr -d '[:space:]')
            value=$(echo "$value" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//; s/^["'\'']//; s/["'\'']$//')

            case "$key" in
                sessions_dir) SESSIONS_DIR="$value" ;;
                format) FORMAT="$value" ;;
                max_duration) MAX_SESSION_DURATION="$value" ;;
            esac
        done < "$CONFIG_FILE"
    fi
}

# Create sessions directory with proper permissions
ensure_sessions_dir() {
    if [ ! -d "$SESSIONS_DIR" ]; then
        mkdir -p "$SESSIONS_DIR"
        chmod 0700 "$SESSIONS_DIR"
    fi

    # Create user subdirectory
    local user_dir="$SESSIONS_DIR/$SESSION_USER"
    if [ ! -d "$user_dir" ]; then
        mkdir -p "$user_dir"
        chmod 0700 "$user_dir"
    fi
}

# Write session metadata
write_metadata() {
    local status="$1"
    local end_time
    end_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat > "$METADATA_FILE" <<EOF
{
    "session_id": "$SESSION_ID",
    "user": "$SESSION_USER",
    "client_ip": "$CLIENT_IP",
    "tty": "$TTY_NAME",
    "start_time": "$SESSION_START",
    "end_time": "$end_time",
    "status": "$status",
    "original_command": $(printf '%s' "$ORIGINAL_COMMAND" | jq -Rs .),
    "format": "$FORMAT",
    "recording_file": "$(basename "$SESSION_FILE")",
    "hostname": "$(hostname -f 2>/dev/null || hostname)",
    "version": "$VERSION"
}
EOF
    chmod 0600 "$METADATA_FILE"
}

# Record session using asciinema format
record_asciinema() {
    local shell="${SHELL:-/bin/bash}"
    local cols
    local lines

    # Get terminal size
    cols=$(tput cols 2>/dev/null || echo 80)
    lines=$(tput lines 2>/dev/null || echo 24)

    # Write asciinema v2 header
    cat > "$SESSION_FILE" <<EOF
{"version": 2, "width": $cols, "height": $lines, "timestamp": $(date +%s), "env": {"SHELL": "$shell", "TERM": "${TERM:-xterm}"}}
EOF

    if [ -n "$ORIGINAL_COMMAND" ]; then
        # Non-interactive: execute command and record output
        exec script -q -c "$ORIGINAL_COMMAND" -f >(
            start_time=$(date +%s.%N)
            while IFS= read -r -n1 char; do
                now=$(date +%s.%N)
                elapsed=$(echo "$now - $start_time" | bc)
                printf '[%s, "o", %s]\n' "$elapsed" "$(printf '%s' "$char" | jq -Rs .)" >> "$SESSION_FILE"
            done
        )
    else
        # Interactive shell with script
        exec script -q -f >(
            start_time=$(date +%s.%N)
            while IFS= read -r -n1 char; do
                now=$(date +%s.%N)
                elapsed=$(echo "$now - $start_time" | bc)
                printf '[%s, "o", %s]\n' "$elapsed" "$(printf '%s' "$char" | jq -Rs .)" >> "$SESSION_FILE"
            done
        ) -c "$shell"
    fi
}

# Record session using ttyrec format
record_ttyrec() {
    local shell="${SHELL:-/bin/bash}"

    if ! command -v ttyrec >/dev/null 2>&1; then
        log_err "ttyrec not installed, falling back to script"
        record_script
        return
    fi

    if [ -n "$ORIGINAL_COMMAND" ]; then
        # Non-interactive command
        exec ttyrec -e "$ORIGINAL_COMMAND" "$SESSION_FILE"
    else
        # Interactive shell
        exec ttyrec -e "$shell" "$SESSION_FILE"
    fi
}

# Fallback: record using script command
record_script() {
    local shell="${SHELL:-/bin/bash}"

    # Change format to indicate script was used
    FORMAT="script"
    SESSION_FILE="${SESSION_FILE%.cast}"
    SESSION_FILE="${SESSION_FILE%.ttyrec}.typescript"

    if [ -n "$ORIGINAL_COMMAND" ]; then
        exec script -q -c "$ORIGINAL_COMMAND" "$SESSION_FILE"
    else
        exec script -q -c "$shell" "$SESSION_FILE"
    fi
}

# Cleanup on exit
cleanup() {
    local exit_code=$?
    local status="completed"

    if [ $exit_code -ne 0 ]; then
        status="error:$exit_code"
    fi

    # Update metadata with end time and status
    if [ -n "$METADATA_FILE" ] && [ -f "$METADATA_FILE" ]; then
        write_metadata "$status"
    fi

    log_info "Session $SESSION_ID ended for user $SESSION_USER (status: $status)"
}

# Handle session timeout
handle_timeout() {
    log_warn "Session $SESSION_ID timed out after $MAX_SESSION_DURATION seconds"
    echo "Session timed out after $MAX_SESSION_DURATION seconds" >&2
    kill -TERM 0
}

# Print usage
usage() {
    cat <<EOF
Usage: $PROG_NAME [OPTIONS]

Record SSH sessions for audit purposes.
Designed to be used as ForceCommand in sshd_config.

Options:
    -h, --help          Show this help message
    -v, --version       Show version
    -c, --config FILE   Configuration file (default: $CONFIG_FILE)
    -d, --dir DIR       Sessions directory (default: $SESSIONS_DIR)
    -f, --format FMT    Recording format: asciinema, ttyrec, script
                        (default: $FORMAT)

Configuration file format:
    sessions_dir = /var/lib/llng-sessions
    format = asciinema
    max_duration = 86400

sshd_config example:
    Match Group recorded-users
        ForceCommand /usr/sbin/llng-session-recorder

Environment variables:
    LLNG_RECORDER_CONFIG    Config file path
    LLNG_SESSIONS_DIR       Sessions directory
    LLNG_RECORDER_FORMAT    Recording format
    LLNG_MAX_SESSION        Max session duration in seconds

EOF
}

# Parse command line arguments
parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "$PROG_NAME version $VERSION"
                exit 0
                ;;
            -c|--config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            -d|--dir)
                SESSIONS_DIR="$2"
                shift 2
                ;;
            -f|--format)
                FORMAT="$2"
                shift 2
                ;;
            *)
                log_err "Unknown option: $1"
                usage >&2
                exit 1
                ;;
        esac
    done
}

# Main
main() {
    parse_args "$@"
    load_config

    # Generate session ID and timestamps
    SESSION_ID=$(generate_session_id)
    SESSION_START=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Setup paths
    ensure_sessions_dir
    local user_dir="$SESSIONS_DIR/$SESSION_USER"
    local date_prefix
    date_prefix=$(date +%Y%m%d-%H%M%S)

    case "$FORMAT" in
        asciinema)
            SESSION_FILE="$user_dir/${date_prefix}_${SESSION_ID}.cast"
            ;;
        ttyrec)
            SESSION_FILE="$user_dir/${date_prefix}_${SESSION_ID}.ttyrec"
            ;;
        *)
            SESSION_FILE="$user_dir/${date_prefix}_${SESSION_ID}.typescript"
            ;;
    esac

    METADATA_FILE="$user_dir/${date_prefix}_${SESSION_ID}.json"

    # Write initial metadata
    write_metadata "active"

    log_info "Session $SESSION_ID started for user $SESSION_USER from $CLIENT_IP"

    # Setup cleanup trap
    trap cleanup EXIT
    trap handle_timeout ALRM

    # Set session timeout (in background)
    if [ "$MAX_SESSION_DURATION" -gt 0 ]; then
        (
            sleep "$MAX_SESSION_DURATION"
            kill -ALRM $$ 2>/dev/null
        ) &
        TIMEOUT_PID=$!
        # Kill timeout process on exit
        trap "kill $TIMEOUT_PID 2>/dev/null; cleanup" EXIT
    fi

    # Start recording based on format
    case "$FORMAT" in
        asciinema)
            record_asciinema
            ;;
        ttyrec)
            record_ttyrec
            ;;
        *)
            record_script
            ;;
    esac
}

main "$@"
